<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Offline Code Debugger</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        
        .editor-container { 
            display: flex; 
            flex-direction: column;
            gap: 20px; 
            height: calc(100vh - 180px);
        }
        
        @media (min-width: 768px) {
            .editor-container {
                flex-direction: row;
            }
        }
        
        .editor-box { 
            flex: 1; 
            min-width: 300px; 
            display: flex; 
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .code-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            position: relative;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
        }
        
        .code-box-container {
            position: relative;
            flex: 1;
            overflow: auto;
            background: #f8f9fa;
        }
        
        .code-box-wrapper {
            position: relative;
            overflow: hidden;
            height: 100%;
        }
        
        .code-box { 
            width: auto;
            min-width: 100%;
            min-height: 200px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
            padding: 15px 15px 15px 50px; 
            border: none;
            background: transparent; 
            resize: none;
            overflow-y: auto;
            overflow-x: auto;
            line-height: 1.5;
            tab-size: 4;
            white-space: pre;
            outline: none;
            font-size: 14px;
            position: relative;
            left: 0;
            color: #2c3e50;
        }
        
        .line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            width: 45px;
            height: 100%;
            padding: 15px 5px;
            border-right: 1px solid #e1e8ed;
            background-color: #f1f3f4;
            text-align: right;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            color: #7f8c8d;
            overflow: hidden;
            user-select: none;
            font-size: 14px;
            z-index: 1;
        }
        
        .error-marker {
            position: absolute;
            background-color: rgba(231, 76, 60, 0.2);
            border-left: 3px solid #e74c3c;
            pointer-events: none;
            z-index: 10;
        }
        
        .error-line {
            background-color: rgba(231, 76, 60, 0.1);
        }
        
        .warning-marker {
            position: absolute;
            background-color: rgba(243, 156, 18, 0.2);
            border-left: 3px solid #f39c12;
            pointer-events: none;
            z-index: 9;
        }
        
        .warning-line {
            background-color: rgba(243, 156, 18, 0.1);
        }
        
        .button-group { 
            display: flex; 
            gap: 10px; 
            margin: 15px 0; 
            flex-wrap: wrap;
        }
        
        button { 
            padding: 10px 16px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            flex: 1;
            min-width: 100px;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .run-btn { background: #27ae60; color: white; }
        .stop-btn { background: #e74c3c; color: white; }
        .reset-btn { background: #f39c12; color: white; }
        .clear-btn { background: #7f8c8d; color: white; }
        .nav-btn { background: #34495e; color: white; flex: 0.5; }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        button:active { transform: translateY(0); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .output-container { 
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .output { 
            flex: 1;
            border: 1px solid #e1e8ed; 
            background: white; 
            border-radius: 8px; 
            overflow: auto;
            position: relative;
            padding: 15px;
        }
        
        .error { 
            color: #e74c3c; 
            font-family: monospace; 
            white-space: pre-wrap; 
            margin-top: 10px;
            overflow: auto;
            max-height: 120px;
            background: rgba(231, 76, 60, 0.1);
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
            font-size: 14px;
        }
        
        .tab-buttons { 
            display: flex; 
            gap: 5px; 
            margin-bottom: 15px; 
            flex-wrap: wrap;
        }
        
        .tab-button { 
            padding: 10px 20px; 
            background: #ecf0f1; 
            border: none; 
            border-radius: 6px 6px 0 0; 
            cursor: pointer; 
            flex: 1;
            min-width: 80px;
            text-align: center;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .tab-button.active { background: #3498db; color: white; }
        .hidden { display: none; }
        
        .resizer {
            width: 12px;
            background: #bdc3c7;
            cursor: col-resize;
            margin: 0 10px;
            border-radius: 6px;
            flex-shrink: 0;
            transition: background 0.2s ease;
        }
        
        .resizer:hover {
            background: #95a5a6;
        }
        
        .error-panel {
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            background: white;
            margin-top: 15px;
            max-height: 200px;
            overflow: auto;
            flex-shrink: 0;
        }
        
        .error-panel h4 {
            margin: 0;
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e1e8ed;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .error-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .error-item {
            padding: 12px 15px;
            border-bottom: 1px solid #f1f3f4;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            transition: background 0.2s ease;
        }
        
        .error-item:hover {
            background: #f8f9fa;
        }
        
        .error-item.active {
            background: #e1f5fe;
        }
        
        .error-type {
            font-weight: bold;
            margin-right: 8px;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .error-type.error {
            color: #c0392b;
            background: rgba(231, 76, 60, 0.1);
        }
        
        .error-type.warning {
            color: #d35400;
            background: rgba(243, 156, 18, 0.1);
        }
        
        .error-location {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .error-navigation {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        
        .current-error {
            flex: 1;
            text-align: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 12px 15px;
            background: #f8f9fa;
            border-top: 1px solid #e1e8ed;
            font-size: 0.9em;
            color: #7f8c8d;
            border-radius: 0 0 8px 8px;
            margin-top: auto;
        }
        
        @media (max-width: 768px) {
            .editor-container {
                flex-direction: column;
                height: auto;
            }
            
            .editor-box {
                min-height: 400px;
            }
            
            .resizer {
                width: 100%;
                height: 12px;
                cursor: row-resize;
                margin: 10px 0;
            }
            
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }
        
        .output-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
        }
        
        .icon {
            font-size: 16px;
        }
        
        /* Accessibility improvements */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Advanced Offline Code Debugger</h1>
        <p class="subtitle">Powerful error checking with navigation. Works completely offline!</p>
    </div>

    <div class="editor-container">
        <div class="editor-box" role="region" aria-labelledby="editor-title">
            <h3 id="editor-title" class="visually-hidden">Code Editor</h3>
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="html">HTML</button>
                <button class="tab-button" data-tab="css">CSS</button>
                <button class="tab-button" data-tab="js">JavaScript</button>
            </div>
            <div class="code-container">
                <div class="code-box-container" id="html-container">
                    <div class="code-box-wrapper">
                        <div class="line-numbers" id="html-line-numbers"></div>
                        <textarea id="html-code" class="code-box" placeholder="Enter HTML here..." spellcheck="false"></textarea>
                    </div>
                </div>
                <div class="code-box-container hidden" id="css-container">
                    <div class="code-box-wrapper">
                        <div class="line-numbers" id="css-line-numbers"></div>
                        <textarea id="css-code" class="code-box" placeholder="Enter CSS here..." spellcheck="false"></textarea>
                    </div>
                </div>
                <div class="code-box-container hidden" id="js-container">
                    <div class="code-box-wrapper">
                        <div class="line-numbers" id="js-line-numbers"></div>
                        <textarea id="js-code" class="code-box" placeholder="Enter JavaScript here..." spellcheck="false"></textarea>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="run-btn" onclick="runCode()"><span class="icon">▶</span> Validate & Run</button>
                <button class="stop-btn" onclick="stopCode()"><span class="icon">■</span> Stop</button>
                <button class="reset-btn" onclick="resetCode()"><span class="icon">↻</span> Reset</button>
                <button class="clear-btn" onclick="clearCode()"><span class="icon">✖</span> Clear</button>
            </div>
            
            <div class="error-navigation">
                <button class="nav-btn" id="prev-error" onclick="navigateError(-1)" disabled><span class="icon">◀</span> Prev</button>
                <div class="current-error" id="current-error">No errors</div>
                <button class="nav-btn" id="next-error" onclick="navigateError(1)" disabled>Next <span class="icon">▶</span></button>
            </div>
            
            <div class="error-panel">
                <h4>Error Summary</h4>
                <ul class="error-list" id="error-list">
                    <li class="error-item">No errors found</li>
                </ul>
            </div>
        </div>
        
        <div class="resizer" id="resizer"></div>
        
        <div class="editor-box" role="region" aria-labelledby="output-title">
            <h3 id="output-title">Output Preview</h3>
            <div class="output-container">
                <div id="output" class="output">
                    <p>Output will appear here after running your code.</p>
                </div>
                <div id="error" class="error"></div>
            </div>
            <div class="status-bar">
                <span id="status">Ready to debug</span>
                <span id="error-count">Errors: 0 | Warnings: 0</span>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentIframe = null;
        let errorMarkers = [];
        let warningMarkers = [];
        let allErrors = [];
        let currentErrorIndex = -1;
        let resizeTimeout;
        let currentTab = 'html';
        let scrollSyncRaf = null;
        let tabErrors = {
            html: [],
            css: [],
            js: []
        };
        let currentTabErrorIndex = {
            html: -1,
            css: -1,
            js: -1
        };
        
        // Enhanced error storage
        const errorTypes = {
            ERROR: 'error',
            WARNING: 'warning'
        };
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Set up tab switching
            document.querySelector('.tab-buttons').addEventListener('click', function(e) {
                if (e.target.classList.contains('tab-button')) {
                    const tabName = e.target.getAttribute('data-tab');
                    showTab(tabName);
                }
            });
            
            // Initialize line numbers for all editors
            setupLineNumbers('html-code', 'html-line-numbers');
            setupLineNumbers('css-code', 'css-line-numbers');
            setupLineNumbers('js-code', 'js-line-numbers');
            
            // Set up resizer
            setupResizers();
            
            // Set up global error handling
            setupGlobalErrorHandling();
            
            // Load default code
            resetCode();
            
            updateStatus("Ready to debug");
        });
        
        // Enhanced global error handling
        function setupGlobalErrorHandling() {
            window.addEventListener('error', function(e) {
                console.error('Global error:', e.error);
                updateStatus('Unexpected error occurred');
            });
            
            window.addEventListener('unhandledrejection', function(e) {
                console.error('Unhandled promise rejection:', e.reason);
                updateStatus('Unhandled promise rejection');
            });
        }
        
        // Show specific tab
        function showTab(tabName) {
            // Hide all code containers
            document.querySelectorAll('.code-box-container').forEach(box => {
                box.classList.add('hidden');
            });
            
            // Show the selected container
            document.getElementById(`${tabName}-container`).classList.remove('hidden');
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            currentTab = tabName;
            
            // Update line numbers for the active tab
            updateLineNumbers(`${tabName}-code`, `${tabName}-line-numbers`);
            
            // Update error navigation for current tab
            updateErrorNavigation();
        }
        
        // Initialize line numbers with debouncing
        function setupLineNumbers(textareaId, lineNumbersId) {
            const textarea = document.getElementById(textareaId);
            const lineNumbers = document.getElementById(lineNumbersId);
            
            if (!textarea || !lineNumbers) return;
            
            function updateLineNumbers() {
                const lines = textarea.value.split('\n');
                lineNumbers.innerHTML = '';
                
                // Add line numbers
                for (let i = 1; i <= lines.length; i++) {
                    const lineNumber = document.createElement('div');
                    lineNumber.textContent = i;
                    lineNumbers.appendChild(lineNumber);
                }
                
                // Match textarea height
                lineNumbers.style.height = textarea.scrollHeight + 'px';
            }
            
            // Debounced update to improve performance
            textarea.addEventListener('input', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(updateLineNumbers, 100);
            });
            
            // Improved scroll synchronization with RAF
            textarea.addEventListener('scroll', () => {
                if (scrollSyncRaf) {
                    cancelAnimationFrame(scrollSyncRaf);
                }
                scrollSyncRaf = requestAnimationFrame(() => {
                    lineNumbers.scrollTop = textarea.scrollTop;
                });
            });
            
            // Enhanced tab key handler with multi-line support
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const value = this.value;
                    
                    // Handle multi-line selection
                    if (start !== end) {
                        const linesBefore = value.substring(0, start).split('\n');
                        const linesAfter = value.substring(end).split('\n');
                        const selectedText = value.substring(start, end);
                        const selectedLines = selectedText.split('\n');
                        
                        // Indent all selected lines
                        const indentedLines = selectedLines.map(line => '    ' + line);
                        const newText = indentedLines.join('\n');
                        
                        this.value = value.substring(0, start) + newText + value.substring(end);
                        this.selectionStart = start;
                        this.selectionEnd = start + newText.length;
                    } else {
                        // Single line indentation
                        this.value = value.substring(0, start) + '    ' + value.substring(end);
                        this.selectionStart = this.selectionEnd = start + 4;
                    }
                    
                    this.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
            
            // Initial setup
            updateLineNumbers();
        }
        
        // Optimized line number update
        function updateLineNumbers(textareaId, lineNumbersId) {
            const textarea = document.getElementById(textareaId);
            const lineNumbers = document.getElementById(lineNumbersId);
            
            if (!textarea || !lineNumbers) return;
            
            const lines = textarea.value.split('\n');
            const currentLineCount = lineNumbers.children.length;
            
            // Only update if line count changed
            if (lines.length !== currentLineCount) {
                lineNumbers.innerHTML = '';
                
                for (let i = 1; i <= lines.length; i++) {
                    const lineNumber = document.createElement('div');
                    lineNumber.textContent = i;
                    lineNumbers.appendChild(lineNumber);
                }
                
                lineNumbers.style.height = textarea.scrollHeight + 'px';
            }
        }
        
        // Clear all error and warning markers
        function clearAllMarkers() {
            errorMarkers.forEach(marker => marker.remove());
            errorMarkers = [];
            warningMarkers.forEach(marker => marker.remove());
            warningMarkers = [];
            
            document.querySelectorAll('.code-box').forEach(box => {
                box.classList.remove('error-line');
                box.classList.remove('warning-line');
            });
        }
        
        // Highlight error or warning line
        function highlightIssue(textareaId, line, message, type = errorTypes.ERROR) {
            const textarea = document.getElementById(textareaId);
            const container = textarea.parentElement;
            
            if (!textarea || !container) return;
            
            const lines = textarea.value.split('\n');
            
            if (line < 1 || line > lines.length) return;
            
            // Remove any existing error/warning classes
            textarea.classList.remove('error-line', 'warning-line');
            
            // Clear existing markers for this textarea
            const markers = type === errorTypes.ERROR ? errorMarkers : warningMarkers;
            markers.forEach((marker, index) => {
                if (marker.parentElement === container) {
                    marker.remove();
                    markers.splice(index, 1);
                }
            });
            
            // Calculate position
            const lineHeight = parseInt(getComputedStyle(textarea).lineHeight) || 20;
            const paddingTop = parseInt(getComputedStyle(textarea).paddingTop) || 15;
            const borderWidth = parseInt(getComputedStyle(textarea).borderTopWidth) || 1;
            
            // Scroll to the issue line (center it if possible)
            const lineTop = (line - 1) * lineHeight;
            const textareaHeight = textarea.clientHeight;
            textarea.scrollTop = Math.max(0, lineTop - textareaHeight / 2 + lineHeight);
            textarea.focus();
            
            // Create marker
            const marker = document.createElement('div');
            marker.className = type === errorTypes.ERROR ? 'error-marker' : 'warning-marker';
            marker.title = message;
            marker.style.top = `${lineTop + paddingTop + borderWidth}px`;
            marker.style.height = `${lineHeight}px`;
            marker.style.left = '45px';
            marker.style.right = '0';
            marker.style.position = 'absolute';
            
            container.appendChild(marker);
            
            if (type === errorTypes.ERROR) {
                errorMarkers.push(marker);
            } else {
                warningMarkers.push(marker);
            }
            
            // Add appropriate line class
            textarea.classList.add(type === errorTypes.ERROR ? 'error-line' : 'warning-line');
        }
        
        // Enhanced HTML validation with multiple error detection
        function validateHTML(html) {
            const errors = [];
            if (!html.trim()) return errors;
            
            try {
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const parserErrors = Array.from(doc.querySelectorAll('parsererror'));
                
                if (parserErrors.length > 0) {
                    // Parse multiple errors from parsererror
                    const errorMsg = parserErrors[0].textContent;
                    let line = 1;
                    
                    // Try different patterns to extract line number
                    const lineMatch = errorMsg.match(/line (\d+)/i) || 
                                     errorMsg.match(/at line (\d+)/i) ||
                                     errorMsg.match(/\((\d+),/);
                    
                    if (lineMatch) line = parseInt(lineMatch[1]);
                    
                    // Clean up error message
                    let cleanMsg = errorMsg.replace(/^XML Parsing Error: /, '')
                                          .replace(/Location: .*/, '')
                                          .trim();
                    
                    errors.push({
                        type: errorTypes.ERROR,
                        message: cleanMsg,
                        line: line,
                        tab: 'html'
                    });
                }
                
                // Additional checks for common HTML issues
                const lines = html.split('\n');
                let openTags = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const lineText = lines[i];
                    const lineNum = i + 1;
                    
                    // Check for unclosed tags
                    const tagMatches = lineText.matchAll(/<(\/?)([a-z][a-z0-9]*)(?![^>]*\/>)[^>]*>/gi);
                    for (const match of tagMatches) {
                        const isClosing = match[1] === '/';
                        const tagName = match[2].toLowerCase();
                        
                        if (!isClosing && !['br', 'hr', 'img', 'input', 'meta', 'link'].includes(tagName)) {
                            openTags.push({tag: tagName, line: lineNum});
                        } else if (isClosing) {
                            const lastOpenTag = openTags.pop();
                            if (!lastOpenTag || lastOpenTag.tag !== tagName) {
                                errors.push({
                                    type: errorTypes.ERROR,
                                    message: `Mismatched tag: </${tagName}>`,
                                    line: lineNum,
                                    tab: 'html'
                                });
                            }
                        }
                    }
                    
                    // Check for common typos
                    if (lineText.includes('scrpt') || lineText.includes('scrip')) {
                        errors.push({
                            type: errorTypes.WARNING,
                            message: "Possible typo: 'scrpt' should be 'script'",
                            line: lineNum,
                            tab: 'html'
                        });
                    }
                    
                    if (lineText.includes('div') && lineText.includes('calss=')) {
                        errors.push({
                            type: errorTypes.WARNING,
                            message: "Possible typo: 'calss' should be 'class'",
                            line: lineNum,
                            tab: 'html'
                        });
                    }
                }
                
                // Check for unclosed tags
                if (openTags.length > 0) {
                    openTags.forEach(tagInfo => {
                        errors.push({
                            type: errorTypes.ERROR,
                            message: `Unclosed <${tagInfo.tag}> tag`,
                            line: tagInfo.line,
                            tab: 'html'
                        });
                    });
                }
                
                return errors;
            } catch (err) {
                errors.push({
                    type: errorTypes.ERROR,
                    message: err.message,
                    line: 1,
                    tab: 'html'
                });
                return errors;
            }
        }

        // Enhanced CSS validation with browser parser
        function validateCSS(css) {
            const errors = [];
            if (!css.trim()) return errors;
            
            try {
                // Use the browser's CSS parser for more accurate validation
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
                
                // Check if styles were parsed successfully
                const sheet = style.sheet;
                if (!sheet) {
                    errors.push({
                        type: errorTypes.ERROR,
                        message: "Invalid CSS syntax",
                        line: 1,
                        tab: 'css'
                    });
                }
                
                document.head.removeChild(style);
                
                // Additional static analysis
                const lines = css.split('\n');
                let braceCount = 0;
                let inRule = false;
                let currentRuleStart = 0;
                let inComment = false;
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];
                    const trimmed = line.trim();
                    const lineNum = i + 1;
                    
                    // Handle block comments
                    if (inComment) {
                        if (line.includes('*/')) {
                            inComment = false;
                            line = line.substring(line.indexOf('*/') + 2);
                        } else {
                            continue; // Skip lines inside block comments
                        }
                    }
                    
                    // Check for block comment start
                    if (line.includes('/*')) {
                        inComment = true;
                        if (line.includes('*/')) {
                            inComment = false;
                            line = line.substring(0, line.indexOf('/*')) + line.substring(line.indexOf('*/') + 2);
                        } else {
                            line = line.substring(0, line.indexOf('/*'));
                        }
                    }
                    
                    // Skip empty lines and single-line comments
                    if (!trimmed || trimmed.startsWith('//')) continue;
                    
                    // Check for unclosed braces
                    const openBraces = (line.match(/{/g) || []).length;
                    const closeBraces = (line.match(/}/g) || []).length;
                    braceCount += openBraces - closeBraces;
                    
                    // Check for syntax errors in rules
                    if (trimmed.endsWith('{') && !trimmed.startsWith('@')) {
                        const selector = trimmed.slice(0, -1).trim();
                        if (!selector) {
                            errors.push({
                                type: errorTypes.ERROR,
                                message: "Missing selector before {",
                                line: lineNum,
                                tab: 'css'
                            });
                        }
                        inRule = true;
                        currentRuleStart = lineNum;
                    }
                    
                    // Check for property: value pairs
                    if (braceCount > 0 && trimmed && !trimmed.endsWith('{') && !trimmed.endsWith('}') && 
                        !trimmed.startsWith('@') && !trimmed.includes(':') && !trimmed.startsWith('/*') && 
                        !trimmed.endsWith('*/')) {
                        // This might be a malformed property
                        errors.push({
                            type: errorTypes.WARNING,
                            message: "Invalid CSS declaration - missing colon?",
                            line: lineNum,
                            tab: 'css'
                        });
                    }
                    
                    // Check for missing semicolons at end of property lines
                    if (braceCount > 0 && trimmed && !trimmed.endsWith('{') && !trimmed.endsWith('}') && 
                        !trimmed.startsWith('@') && trimmed.includes(':') && !trimmed.endsWith(';') && 
                        !trimmed.includes('{') && !trimmed.includes('}') && !trimmed.startsWith('/*') && 
                        !trimmed.endsWith('*/') && i < lines.length - 1) {
                        const nextLine = lines[i + 1].trim();
                        if (nextLine && !nextLine.endsWith('}') && !nextLine.startsWith('/*')) {
                            errors.push({
                                type: errorTypes.WARNING,
                                message: "Missing semicolon",
                                line: lineNum,
                                tab: 'css'
                            });
                        }
                    }
                    
                    // Check for rule termination
                    if (trimmed.endsWith('}') && inRule) {
                        inRule = false;
                    }
                }
                
                if (braceCount !== 0) {
                    errors.push({
                        type: errorTypes.ERROR,
                        message: `Unbalanced braces (missing ${braceCount > 0 ? '}' : '{'})`,
                        line: lines.length,
                        tab: 'css'
                    });
                }
                
                return errors;
            } catch (err) {
                // Extract line number from CSS error
                let line = 1;
                const lineMatch = err.message.match(/line (\d+)/i) || 
                                 err.stack.match(/<anonymous>:(\d+):(\d+)/i);
                if (lineMatch) line = parseInt(lineMatch[1]);
                
                errors.push({
                    type: errorTypes.ERROR,
                    message: err.message.replace(/^CSS\..*?: /, ''),
                    line: line,
                    tab: 'css'
                });
                return errors;
            }
        }

        // Enhanced JS validation with multiple error detection
        function validateJS(js) {
            const errors = [];
            if (!js.trim()) return errors;
            
            try {
                // Syntax validation
                new Function(js);
                
                // Additional static analysis
                const lines = js.split('\n');
                
                // Check for common issues
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];
                    const lineNum = i + 1;
                    let trimmed = line.trim();
                    
                    // Skip empty lines
                    if (!trimmed) continue;
                    
                    // Check for assignment in condition (common typo)
                    if (line.includes('if (') && line.includes('=') && !line.includes('==') && !line.includes('===') && 
                        line.indexOf('=') < line.indexOf(')') && line.indexOf('=') > line.indexOf('(')) {
                        // Make sure it's not in a string or comment
                        if (!isInStringOrComment(line, line.indexOf('='))) {
                            errors.push({
                                type: errorTypes.WARNING,
                                message: "Possible assignment in condition, use == or ===",
                                line: lineNum,
                                tab: 'js'
                            });
                        }
                    }
                    
                    // Check for missing semicolons (simple heuristic)
                    const lastChar = trimmed[trimmed.length - 1];
                    if (lastChar && ![';', '{', '}', ')', '(', ',', '.', '=', '+', '-', '*', '/'].includes(lastChar) &&
                        !trimmed.startsWith('//') && !trimmed.startsWith('/*') && !trimmed.endsWith('*/') &&
                        !trimmed.startsWith('function') && !trimmed.startsWith('if') && !trimmed.startsWith('for') && 
                        !trimmed.startsWith('while') && !trimmed.startsWith('const') && !trimmed.startsWith('let') && 
                        !trimmed.startsWith('var') && !trimmed.startsWith('return') && !trimmed.startsWith('console')) {
                        errors.push({
                            type: errorTypes.WARNING,
                            message: "Missing semicolon",
                            line: lineNum,
                            tab: 'js'
                        });
                    }
                }
                
                return errors;
                
                // Helper function to check if position is in string or comment
                function isInStringOrComment(text, position) {
                    let inSingleLineComment = false;
                    let inMultiLineComment = false;
                    let inString = false;
                    let stringChar = '';
                    
                    for (let i = 0; i < Math.min(position, text.length); i++) {
                        const char = text[i];
                        const nextChar = text[i + 1];
                        
                        if (!inSingleLineComment && !inMultiLineComment && !inString) {
                            if (char === '/' && nextChar === '/') {
                                inSingleLineComment = true;
                                i++; // Skip next char
                            } else if (char === '/' && nextChar === '*') {
                                inMultiLineComment = true;
                                i++; // Skip next char
                            } else if (char === '"' || char === "'" || char === '`') {
                                inString = true;
                                stringChar = char;
                            }
                        } else if (inSingleLineComment) {
                            // Single line comment continues to end of line
                            // We're checking before position, so no need to break
                        } else if (inMultiLineComment && char === '*' && nextChar === '/') {
                            inMultiLineComment = false;
                            i++; // Skip next char
                        } else if (inString && char === stringChar) {
                            // Check for escape character
                            if (text[i - 1] !== '\\') {
                                inString = false;
                            }
                        }
                    }
                    
                    return inSingleLineComment || inMultiLineComment || inString;
                }
            } catch (err) {
                // Extract line number from JS error
                const lineMatch = err.stack.match(/<anonymous>:(\d+):(\d+)/i) || 
                                 err.stack.match(/eval:(\d+):(\d+)/i);
                const line = lineMatch ? parseInt(lineMatch[1]) : 1;
                
                errors.push({
                    type: errorTypes.ERROR,
                    message: err.message,
                    line: line,
                    tab: 'js'
                });
                return errors;
            }
        }

        // Stop running code
        function stopCode() {
            if (currentIframe) {
                currentIframe.remove();
                currentIframe = null;
                document.getElementById("error").textContent = "Execution stopped.";
                updateStatus("Execution stopped");
            }
        }

        // Reset to default code
        function resetCode() {
            document.getElementById("html-code").value = `<!DOCTYPE html>
<html>
<head>
    <title>Test Page</title>
</head>
<body>
    <h1>Welcome to the Debugger</h1>
    <div id="demo">Hello, World!</div>
    <button onclick="testFunc()">Click me</button>
    
    <script>
        // This will cause an error
        function testFunc() {
            console.log("Button clicked!");
            undefinedFunction(); // This function doesn't exist
        }
        
        // This will work
        function workingFunc() {
            document.getElementById("demo").style.color = "blue";
            console.log("Function executed successfully!");
        }
    <\/script>
</body>
</html>`;
            document.getElementById("css-code").value = `/* Sample CSS with intentional errors */
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #f0f0f0;
}

#demo { 
    color: red; 
    font-size: 24px; 
    text-align: center;
    padding: 10px;
    missing-property: test; /* This property doesn't exist */
}

.container {
    width: 100%
    /* Missing semicolon above and unclosed rule below */
    background: blue

.button {
    background: #0078d4;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
}

/* This rule is correct */
h1 {
    color: #2c3e50;
    text-align: center;
    margin-bottom: 20px;
}`;
            document.getElementById("js-code").value = `// Sample JavaScript with multiple errors
document.addEventListener('DOMContentLoaded', function() {
    const demo = document.getElementById("demo");
    if (demo) {
        demo.style.fontWeight = "bold";
        demo.innerHTML = "Welcome to the Debugger!";
    }
    
    // Syntax error - missing closing parenthesis
    console.log("Testing";
    
    // Runtime error - calling undefined function
    undefinedFunction();
    
    // Another error - using undefined variable
    x = y + z;
});

// Function with issues
function calculateTotal(price, quantity {
    // Missing closing parenthesis above
    total = price * quantity;
    return total;
}

// More complex example with multiple issues
const data = {
    name: "Test",
    value: 42
;

console.log(data.name;
console.log(data.value)

// This function works correctly
function correctFunction() {
    console.log("This function works properly!");
    return true;
}`;
            clearCode();
            updateAllLineNumbers();
        }

        // Clear output and errors
        function clearCode() {
            stopCode();
            document.getElementById("output").innerHTML = "<p>Output will appear here after running your code.</p>";
            document.getElementById("error").textContent = "";
            clearAllMarkers();
            allErrors = [];
            currentErrorIndex = -1;
            tabErrors = { html: [], css: [], js: [] };
            currentTabErrorIndex = { html: -1, css: -1, js: -1 };
            updateErrorNavigation();
            updateErrorSummary();
            updateErrorCount();
            updateStatus("Cleared");
        }
        
        // Update all line numbers
        function updateAllLineNumbers() {
            updateLineNumbers('html-code', 'html-line-numbers');
            updateLineNumbers('css-code', 'css-line-numbers');
            updateLineNumbers('js-code', 'js-line-numbers');
        }
        
        // Update status bar
        function updateStatus(message) {
            document.getElementById("status").textContent = message;
        }
        
        // Update error count display
        function updateErrorCount() {
            const errorCount = allErrors.filter(e => e.type === errorTypes.ERROR).length;
            const warningCount = allErrors.filter(e => e.type === errorTypes.WARNING).length;
            document.getElementById("error-count").textContent = `Errors: ${errorCount} | Warnings: ${warningCount}`;
        }
        
        // Update error summary panel
        function updateErrorSummary() {
            const errorList = document.getElementById("error-list");
            errorList.innerHTML = "";
            
            if (allErrors.length === 0) {
                const item = document.createElement("li");
                item.className = "error-item";
                item.textContent = "No errors found";
                errorList.appendChild(item);
                return;
            }
            
            allErrors.forEach((error, index) => {
                const item = document.createElement("li");
                item.className = `error-item ${index === currentErrorIndex ? 'active' : ''}`;
                item.innerHTML = `
                    <div>
                        <span class="error-type ${error.type}">${error.type.toUpperCase()}</span>
                        ${error.message}
                    </div>
                    <div class="error-location">Line ${error.line}</div>
                `;
                item.addEventListener("click", () => {
                    navigateToError(index);
                });
                errorList.appendChild(item);
            });
        }
        
        // Update error navigation buttons
        function updateErrorNavigation() {
            const prevBtn = document.getElementById("prev-error");
            const nextBtn = document.getElementById("next-error");
            const currentErrorDisplay = document.getElementById("current-error");
            
            // Get errors for current tab
            const currentTabErrors = tabErrors[currentTab] || [];
            
            if (currentTabErrors.length === 0) {
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                currentErrorDisplay.textContent = "No errors";
                return;
            }
            
            const currentIndex = currentTabErrorIndex[currentTab];
            
            prevBtn.disabled = currentIndex <= 0;
            nextBtn.disabled = currentIndex >= currentTabErrors.length - 1;
            
            if (currentTabErrors.length > 0 && currentIndex >= 0) {
                currentErrorDisplay.textContent = `Error ${currentIndex + 1} of ${currentTabErrors.length}`;
            } else {
                currentErrorDisplay.textContent = "No errors";
            }
        }
        
        // Navigate to specific error
        function navigateToError(index) {
            if (index < 0 || index >= allErrors.length) return;
            
            currentErrorIndex = index;
            const error = allErrors[index];
            
            // Update tab-specific error index
            const tabErrorList = tabErrors[error.tab];
            const tabIndex = tabErrorList ? tabErrorList.findIndex(e => 
                e.line === error.line && e.message === error.message && e.type === error.type
            ) : -1;
            
            if (tabIndex !== -1) {
                currentTabErrorIndex[error.tab] = tabIndex;
            }
            
            // Switch to the correct tab
            if (error.tab !== currentTab) {
                showTab(error.tab);
            }
            
            // Highlight the error
            highlightIssue(`${error.tab}-code`, error.line, error.message, error.type);
            
            // Update navigation
            updateErrorNavigation();
            updateErrorSummary();
            
            updateStatus(`Navigated to ${error.type} on line ${error.line}`);
        }
        
        // Navigate to next/previous error
        function navigateError(direction) {
            const currentTabErrors = tabErrors[currentTab] || [];
            if (currentTabErrors.length === 0) return;
            
            let currentIndex = currentTabErrorIndex[currentTab];
            if (currentIndex === -1) currentIndex = 0;
            
            // Calculate new position
            let newIndex = currentIndex + direction;
            if (newIndex < 0) newIndex = currentTabErrors.length - 1;
            if (newIndex >= currentTabErrors.length) newIndex = 0;
            
            // Find the global index of this error
            const error = currentTabErrors[newIndex];
            const globalIndex = allErrors.findIndex(e => 
                e.tab === error.tab && e.line === error.line && 
                e.message === error.message && e.type === error.type
            );
            
            if (globalIndex !== -1) {
                navigateToError(globalIndex);
            }
        }

        // Run code with full validation
        function runCode() {
            const html = document.getElementById("html-code").value;
            const css = document.getElementById("css-code").value;
            const js = document.getElementById("js-code").value;
            
            const output = document.getElementById("output");
            const errorDisplay = document.getElementById("error");
            
            // Clear previous
            stopCode();
            clearAllMarkers();
            errorDisplay.textContent = "";
            allErrors = [];
            currentErrorIndex = -1;
            tabErrors = { html: [], css: [], js: [] };
            currentTabErrorIndex = { html: -1, css: -1, js: -1 };
            
            updateStatus("Validating code...");
            
            // Validate all code types
            const htmlErrors = validateHTML(html);
            const cssErrors = validateCSS(css);
            const jsErrors = validateJS(js);
            
            // Combine all errors and organize by tab
            allErrors = [...htmlErrors, ...cssErrors, ...jsErrors];
            tabErrors.html = htmlErrors;
            tabErrors.css = cssErrors;
            tabErrors.js = jsErrors;
            
            // Update UI with errors
            updateErrorCount();
            updateErrorSummary();
            updateErrorNavigation();
            
            // If there are errors, show the first one
            if (allErrors.length > 0) {
                // Find first error for current tab, or first error overall
                let firstErrorIndex = 0;
                const currentTabError = tabErrors[currentTab];
                if (currentTabError && currentTabError.length > 0) {
                    firstErrorIndex = allErrors.findIndex(e => 
                        e.tab === currentTabError[0].tab && 
                        e.line === currentTabError[0].line && 
                        e.message === currentTabError[0].message
                    );
                }
                
                navigateToError(firstErrorIndex);
                errorDisplay.textContent = `Found ${allErrors.length} issues. Use navigation to review them.`;
                updateStatus(`Found ${allErrors.length} issues`);
                return;
            }
            
            updateStatus("Running code...");
            
            // Create new iframe for output
            currentIframe = document.createElement("iframe");
            currentIframe.className = "output-frame";
            currentIframe.sandbox = "allow-scripts allow-same-origin";
            output.innerHTML = "";
            output.appendChild(currentIframe);
            
            const iframeDoc = currentIframe.contentDocument || currentIframe.contentWindow.document;
            
            try {
                // Generate a unique ID for this iframe for message identification
                const iframeId = 'iframe_' + Date.now();
                currentIframe.dataset.iframeId = iframeId;
                
                iframeDoc.open();
                iframeDoc.write(`
                    <!DOCTYPE html>
                    <html>
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <style>${css}</style>
                        </head>
                        <body>${html}
                            <script>
                                // Enhanced error handling for runtime errors with postMessage
                                window.addEventListener('error', function(e) {
                                    const errorInfo = {
                                        type: 'runtimeError',
                                        iframeId: '${iframeId}',
                                        message: e.message,
                                        filename: e.filename,
                                        lineno: e.lineno,
                                        colno: e.colno,
                                        stack: e.error?.stack
                                    };
                                    window.parent.postMessage(errorInfo, '*');
                                    return false;
                                });
                                
                                // Catch unhandled promise rejections
                                window.addEventListener('unhandledrejection', function(e) {
                                    const errorInfo = {
                                        type: 'unhandledRejection',
                                        iframeId: '${iframeId}',
                                        message: "Unhandled Promise Rejection: " + e.reason,
                                        lineno: 1
                                    };
                                    window.parent.postMessage(errorInfo, '*');
                                });
                                
                                try {
                                    ${js}
                                } catch (err) {
                                    const errorInfo = {
                                        type: 'executionError',
                                        iframeId: '${iframeId}',
                                        message: err.message,
                                        lineno: err.lineNumber || 1,
                                        stack: err.stack
                                    };
                                    window.parent.postMessage(errorInfo, '*');
                                }
                            <\/script>
                        </body>
                    </html>
                `);
                iframeDoc.close();
                updateStatus("Code executed successfully");
            } catch (err) {
                displayError("Frame Error: " + err.message);
                updateStatus("Error executing code");
            }
        }
        
        // Enhanced message listener with security validation
        window.addEventListener('message', function(event) {
            // Security check - only accept messages from same origin
            if (event.origin !== window.location.origin) return;
            
            // Check if this message is from our iframe
            if (currentIframe && event.data && event.data.iframeId === currentIframe.dataset.iframeId) {
                const errorInfo = event.data;
                
                const error = {
                    type: errorTypes.ERROR,
                    message: errorInfo.message,
                    line: errorInfo.lineno || 1,
                    tab: 'js' // Runtime errors are always from JS
                };
                
                allErrors.push(error);
                if (!tabErrors.js) tabErrors.js = [];
                tabErrors.js.push(error);
                
                updateErrorCount();
                updateErrorSummary();
                
                // If this is the first error, navigate to it
                if (allErrors.length === 1) {
                    navigateToError(0);
                }
                
                document.getElementById("error").textContent = `Runtime Error: ${errorInfo.message}`;
                updateStatus("Runtime error detected");
            }
        });
        
        function displayError(err) {
            document.getElementById("error").textContent = err;
            updateStatus("Error detected");
        }

        // Make panels resizable
        function setupResizers() {
            const container = document.querySelector('.editor-container');
            const leftPanel = container.children[0];
            const resizer = document.getElementById('resizer');
            const rightPanel = container.children[2];
            
            let isResizing = false;
            
            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                const percent = Math.min(Math.max((e.clientX - containerRect.left) / containerRect.width * 100, 20), 80);
                
                leftPanel.style.flex = `0 0 ${percent}%`;
                rightPanel.style.flex = `0 0 ${100 - percent}%`;
            });
            
            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
            });
            
            // Handle touch events for mobile
            resizer.addEventListener('touchstart', (e) => {
                isResizing = true;
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;
                
                const touch = e.touches[0];
                const containerRect = container.getBoundingClientRect();
                const percent = Math.min(Math.max((touch.clientX - containerRect.left) / containerRect.width * 100, 20), 80);
                
                leftPanel.style.flex = `0 0 ${percent}%`;
                rightPanel.style.flex = `0 0 ${100 - percent}%`;
                
                e.preventDefault();
            });
            
            document.addEventListener('touchend', () => {
                isResizing = false;
            });
        }
    </script>
</body>
</html>
