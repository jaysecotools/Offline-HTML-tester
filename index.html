<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Offline Code Debugger</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        
        .editor-container { 
            display: flex; 
            flex-direction: column;
            gap: 20px; 
            height: calc(100vh - 180px);
        }
        
        @media (min-width: 768px) {
            .editor-container {
                flex-direction: row;
            }
        }
        
        .editor-box { 
            flex: 1; 
            min-width: 300px; 
            display: flex; 
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .code-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            position: relative;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
        }
        
        .code-box-container {
            position: relative;
            flex: 1;
            overflow: hidden;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .code-box-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
            background: #f8f9fa;
        }
        
        .code-box { 
            width: 100%;
            min-height: 100%;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
            padding: 15px 15px 15px 50px;
            margin: 0;
            border: none;
            background: transparent; 
            resize: none;
            overflow: hidden;
            line-height: 21px;
            tab-size: 4;
            white-space: pre;
            outline: none;
            font-size: 14px;
            color: #2c3e50;
            display: block;
            position: relative;
            z-index: 1;
            box-sizing: border-box;
        }
        
        .line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            width: 45px;
            height: auto;
            padding: 15px 5px;
            border-right: 1px solid #e1e8ed;
            background-color: #f1f3f4;
            text-align: right;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            color: #7f8c8d;
            user-select: none;
            font-size: 14px;
            line-height: 21px;
            z-index: 2;
            pointer-events: none;
            box-sizing: border-box;
        }
        
        .line-numbers div {
            height: 21px;
            line-height: 21px;
            min-height: 21px;
            box-sizing: border-box;
        }
        
        .error-marker {
            position: absolute;
            background-color: rgba(231, 76, 60, 0.2);
            border-left: 3px solid #e74c3c;
            pointer-events: none;
            z-index: 3;
            left: 45px;
            right: 0;
        }
        
        .error-line {
            background-color: rgba(231, 76, 60, 0.1);
        }
        
        .warning-marker {
            position: absolute;
            background-color: rgba(243, 156, 18, 0.2);
            border-left: 3px solid #f39c12;
            pointer-events: none;
            z-index: 3;
            left: 45px;
            right: 0;
        }
        
        .warning-line {
            background-color: rgba(243, 156, 18, 0.1);
        }
        
        .button-group { 
            display: flex; 
            gap: 10px; 
            margin: 15px 0; 
            flex-wrap: wrap;
        }
        
        button { 
            padding: 10px 16px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            flex: 1;
            min-width: 100px;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .run-btn { background: #27ae60; color: white; }
        .stop-btn { background: #e74c3c; color: white; }
        .reset-btn { background: #f39c12; color: white; }
        .clear-btn { background: #7f8c8d; color: white; }
        .nav-btn { background: #34495e; color: white; flex: 0.5; }
        .override-btn { background: #9b59b6; color: white; }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        button:active { transform: translateY(0); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .output-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .output { 
            flex: 1;
            border: 1px solid #e1e8ed; 
            background: white; 
            border-radius: 8px; 
            overflow: auto;
            position: relative;
            padding: 15px;
        }
        
        .error { 
            color: #e74c3c; 
            font-family: monospace; 
            white-space: pre-wrap; 
            margin-top: 10px;
            overflow: auto;
            max-height: 120px;
            background: rgba(231, 76, 60, 0.1);
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
            font-size: 14px;
        }
        
        .tab-buttons { 
            display: flex; 
            gap: 5px; 
            margin-bottom: 15px; 
            flex-wrap: wrap;
        }
        
        .tab-button { 
            padding: 10px 20px; 
            background: #ecf0f1; 
            border: none; 
            border-radius: 6px 6px 0 0; 
            cursor: pointer; 
            flex: 1;
            min-width: 80px;
            text-align: center;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .tab-button.active { background: #3498db; color: white; }
        .hidden { display: none; }
        
        .resizer {
            width: 12px;
            background: #bdc3c7;
            cursor: col-resize;
            margin: 0 10px;
            border-radius: 6px;
            flex-shrink: 0;
            transition: background 0.2s ease;
        }
        
        .resizer:hover {
            background: #95a5a6;
        }
        
        .error-panel {
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            background: white;
            margin-top: 15px;
            max-height: 200px;
            overflow: auto;
            flex-shrink: 0;
        }
        
        .error-panel h4 {
            margin: 0;
            padding: 12px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e1e8ed;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .error-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .error-item {
            padding: 12px 15px;
            border-bottom: 1px solid #f1f3f4;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            transition: background 0.2s ease;
        }
        
        .error-item:hover {
            background: #f8f9fa;
        }
        
        .error-item.active {
            background: #e1f5fe;
        }
        
        .error-type {
            font-weight: bold;
            margin-right: 8px;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .error-type.error {
            color: #c0392b;
            background: rgba(231, 76, 60, 0.1);
        }
        
        .error-type.warning {
            color: #d35400;
            background: rgba(243, 156, 18, 0.1);
        }
        
        .error-location {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .error-navigation {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        
        .current-error {
            flex: 1;
            text-align: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 12px 15px;
            background: #f8f9fa;
            border-top: 1px solid #e1e8ed;
            font-size: 0.9em;
            color: #7f8c8d;
            border-radius: 0 0 8px 8px;
            margin-top: auto;
        }
        
        @media (max-width: 768px) {
            .editor-container {
                flex-direction: column;
                height: auto;
            }
            
            .editor-box {
                min-height: 400px;
            }
            
            .resizer {
                width: 100%;
                height: 12px;
                cursor: row-resize;
                margin: 10px 0;
            }
            
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }
        
        .output-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
        }
        
        .icon {
            font-size: 16px;
        }
        
        /* Accessibility improvements */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Override toggle styles */
        .override-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e1e8ed;
        }
        
        .override-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .override-toggle label {
            font-weight: 600;
            color: #2c3e50;
            cursor: pointer;
        }
        
        .override-note {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .override-active {
            border-color: #9b59b6;
            background: rgba(155, 89, 182, 0.05);
        }
        
        .override-btn.active {
            background: #8e44ad;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Advanced Offline Code Debugger</h1>
        <p class="subtitle">Powerful error checking with navigation. Works completely offline!</p>
    </div>

    <div class="editor-container">
        <div class="editor-box" role="region" aria-labelledby="editor-title">
            <h3 id="editor-title" class="visually-hidden">Code Editor</h3>
            <div class="tab-buttons">
                <button class="tab-button active" data-tab="html">HTML</button>
                <button class="tab-button" data-tab="css">CSS</button>
                <button class="tab-button" data-tab="js">JavaScript</button>
            </div>
            <div class="code-container">
                <div class="code-box-container" id="html-container">
                    <div class="code-box-wrapper">
                        <div class="line-numbers" id="html-line-numbers"></div>
                        <textarea id="html-code" class="code-box" placeholder="Enter HTML here..." spellcheck="false"></textarea>
                    </div>
                </div>
                <div class="code-box-container hidden" id="css-container">
                    <div class="code-box-wrapper">
                        <div class="line-numbers" id="css-line-numbers"></div>
                        <textarea id="css-code" class="code-box" placeholder="Enter CSS here..." spellcheck="false"></textarea>
                    </div>
                </div>
                <div class="code-box-container hidden" id="js-container">
                    <div class="code-box-wrapper">
                        <div class="line-numbers" id="js-line-numbers"></div>
                        <textarea id="js-code" class="code-box" placeholder="Enter JavaScript here..." spellcheck="false"></textarea>
                    </div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="run-btn" id="run-btn"><span class="icon">▶</span> Validate & Run</button>
                <button class="override-btn" id="override-btn"><span class="icon">⚠</span> Force Run</button>
                <button class="stop-btn" id="stop-btn"><span class="icon">■</span> Stop</button>
                <button class="reset-btn" id="reset-btn"><span class="icon">↻</span> Reset</button>
                <button class="clear-btn" id="clear-btn"><span class="icon">✖</span> Clear</button>
            </div>
            
            <div class="override-toggle" id="override-toggle">
                <input type="checkbox" id="override-checkbox">
                <label for="override-checkbox">Always override errors and warnings</label>
                <div class="override-note">When checked, code will always run regardless of validation issues</div>
            </div>
            
            <div class="error-navigation">
                <button class="nav-btn" id="prev-error"><span class="icon">◀</span> Prev</button>
                <div class="current-error" id="current-error">No errors</div>
                <button class="nav-btn" id="next-error">Next <span class="icon">▶</span></button>
            </div>
            
            <div class="error-panel">
                <h4>Error Summary</h4>
                <ul class="error-list" id="error-list">
                    <li class="error-item">No errors found</li>
                </ul>
            </div>
        </div>
        
        <div class="resizer" id="resizer"></div>
        
        <div class="editor-box" role="region" aria-labelledby="output-title">
            <h3 id="output-title">Output Preview</h3>
            <div class="output-container">
                <div id="output" class="output">
                    <p>Output will appear here after running your code.</p>
                </div>
                <div id="error" class="error"></div>
            </div>
            <div class="status-bar">
                <span id="status">Ready to debug</span>
                <span id="error-count">Errors: 0 | Warnings: 0</span>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentIframe = null;
        let errorMarkers = [];
        let warningMarkers = [];
        let allErrors = [];
        let currentErrorIndex = -1;
        let resizeTimeout;
        let currentTab = 'html';
        let scrollSyncRaf = null;
        let tabErrors = {
            html: [],
            css: [],
            js: []
        };
        let currentTabErrorIndex = {
            html: -1,
            css: -1,
            js: -1
        };
        
        // Override state
        let overrideEnabled = false;
        let alwaysOverride = false;
        
        // Enhanced error storage
        const errorTypes = {
            ERROR: 'error',
            WARNING: 'warning'
        };
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
        
        function initializeApp() {
            console.log("Initializing app...");
            
            // Set up tab switching
            const tabButtons = document.querySelector('.tab-buttons');
            if (tabButtons) {
                tabButtons.addEventListener('click', function(e) {
                    if (e.target.classList.contains('tab-button')) {
                        const tabName = e.target.getAttribute('data-tab');
                        console.log("Switching to tab:", tabName);
                        showTab(tabName);
                    }
                });
            }
            
            // Set default content for testing
            setDefaultContent();
            
            // Initialize line numbers for all editors
            initializeAllEditors();
            
            // Set up button event listeners with proper error handling
            setupButtonListeners();
            
            // Set up override toggle
            const overrideCheckbox = document.getElementById('override-checkbox');
            if (overrideCheckbox) {
                overrideCheckbox.addEventListener('change', function(e) {
                    alwaysOverride = e.target.checked;
                    updateOverrideToggle();
                });
            }
            
            // Set up resizer
            setupResizers();
            
            // Set up global error handling
            setupGlobalErrorHandling();
            
            // Ensure HTML tab is active
            showTab('html');
            
            // Final initialization
            setTimeout(function() {
                updateAllLineNumbers();
                updateStatus("Ready to debug");
                console.log("App initialized successfully");
            }, 100);
        }
        
        // Initialize all editors with proper event handling
        function initializeAllEditors() {
            setupLineNumbers('html-code', 'html-line-numbers');
            setupLineNumbers('css-code', 'css-line-numbers');
            setupLineNumbers('js-code', 'js-line-numbers');
        }
        
        function setDefaultContent() {
            // Set default content for testing if empty
            if (!document.getElementById('html-code').value) {
                document.getElementById('html-code').value = `<!DOCTYPE html>
<html>
<head>
    <title>Test Page</title>
</head>
<body>
    <h1>Hello World</h1>
    <p>This is a test paragraph</p>
    <div id="output"></div>
</body>
</html>`;
            }
            
            if (!document.getElementById('css-code').value) {
                document.getElementById('css-code').value = `body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background-color: #f5f5f5;
}

h1 {
    color: #2c3e50;
    text-align: center;
}

p {
    color: #7f8c8d;
    line-height: 1.6;
}`;
            }
            
            if (!document.getElementById('js-code').value) {
                document.getElementById('js-code').value = `// Simple JavaScript example
console.log('Hello from JavaScript!');

function greet(name) {
    return 'Hello, ' + name + '!';
}

// Call the function
const message = greet('World');
document.getElementById('output').textContent = message;

// This will cause a warning in validation
if (x = 5) {
    console.log('x is 5');
}`;
            }
        }
        
        function setupButtonListeners() {
            console.log("Setting up button listeners...");
            
            // Use event delegation for buttons
            document.addEventListener('click', function(e) {
                if (e.target.matches('#run-btn, #run-btn *')) {
                    runCode();
                } else if (e.target.matches('#override-btn, #override-btn *')) {
                    forceRunCode();
                } else if (e.target.matches('#stop-btn, #stop-btn *')) {
                    stopCode();
                } else if (e.target.matches('#reset-btn, #reset-btn *')) {
                    resetCode();
                } else if (e.target.matches('#clear-btn, #clear-btn *')) {
                    clearCode();
                } else if (e.target.matches('#prev-error, #prev-error *')) {
                    navigateError(-1);
                } else if (e.target.matches('#next-error, #next-error *')) {
                    navigateError(1);
                }
            });
            
            console.log("Button listeners setup complete");
        }
        
        // Enhanced global error handling
        function setupGlobalErrorHandling() {
            window.addEventListener('error', function(e) {
                console.error('Global error:', e.error);
                updateStatus('Unexpected error occurred');
            });
            
            window.addEventListener('unhandledrejection', function(e) {
                console.error('Unhandled promise rejection:', e.reason);
                updateStatus('Unhandled promise rejection');
            });
        }
        
        // Show specific tab
        function showTab(tabName) {
            // Hide all code containers
            document.querySelectorAll('.code-box-container').forEach(function(box) {
                box.classList.add('hidden');
            });
            
            // Show the selected container
            const container = document.getElementById(tabName + '-container');
            if (container) {
                container.classList.remove('hidden');
            }
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(function(btn) {
                btn.classList.remove('active');
            });
            const activeTab = document.querySelector('[data-tab="' + tabName + '"]');
            if (activeTab) {
                activeTab.classList.add('active');
            }
            
            currentTab = tabName;
            
            // Update line numbers for the active tab
            updateLineNumbersForTab(tabName);
            
            // Update error navigation for current tab
            updateErrorNavigation();
            
            // Focus the textarea for the active tab
            setTimeout(() => {
                const textarea = document.getElementById(tabName + '-code');
                if (textarea) {
                    textarea.focus();
                }
            }, 50);
        }
        
        // Initialize line numbers - SIMPLIFIED WORKING VERSION
        function setupLineNumbers(textareaId, lineNumbersId) {
            const textarea = document.getElementById(textareaId);
            const lineNumbers = document.getElementById(lineNumbersId);
            
            if (!textarea || !lineNumbers) return;
            
            const LINE_HEIGHT = 21;
            const PADDING_TOP = 15;
            const PADDING_BOTTOM = 15;
            
            // Function to update line numbers
            function updateLineNumbers() {
                const lines = textarea.value.split('\n');
                const lineCount = lines.length;
                
                // Clear existing line numbers
                lineNumbers.innerHTML = '';
                
                // Add line numbers
                for (let i = 1; i <= lineCount; i++) {
                    const lineNumber = document.createElement('div');
                    lineNumber.textContent = i;
                    lineNumber.style.height = LINE_HEIGHT + 'px';
                    lineNumber.style.lineHeight = LINE_HEIGHT + 'px';
                    lineNumber.style.boxSizing = 'border-box';
                    lineNumbers.appendChild(lineNumber);
                }
                
                // Calculate total height needed
                const totalHeight = (lineCount * LINE_HEIGHT) + PADDING_TOP + PADDING_BOTTOM;
                
                // Set minimum heights
                textarea.style.minHeight = totalHeight + 'px';
                lineNumbers.style.minHeight = totalHeight + 'px';
                
                // Sync scroll
                syncScroll();
            }
            
            // Sync scroll between line numbers and textarea
            function syncScroll() {
                const wrapper = textarea.parentElement;
                if (wrapper) {
                    // Move line numbers with transform
                    lineNumbers.style.transform = `translateY(-${wrapper.scrollTop}px)`;
                }
            }
            
            // Setup scroll event
            const wrapper = textarea.parentElement;
            if (wrapper) {
                wrapper.addEventListener('scroll', syncScroll);
            }
            
            // Update on input
            textarea.addEventListener('input', function() {
                updateLineNumbers();
            });
            
            // Update on paste
            textarea.addEventListener('paste', function() {
                setTimeout(updateLineNumbers, 0);
            });
            
            // Handle keyboard events
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    const value = this.value;
                    
                    if (start !== end) {
                        // Multi-line indentation
                        const selectedText = value.substring(start, end);
                        const selectedLines = selectedText.split('\n');
                        
                        const indentedLines = selectedLines.map(function(line) {
                            return e.shiftKey ? 
                                (line.startsWith('    ') ? line.substring(4) : line.replace(/^\s{1,4}/, '')) :
                                '    ' + line;
                        });
                        
                        const newText = indentedLines.join('\n');
                        this.value = value.substring(0, start) + newText + value.substring(end);
                        this.selectionStart = start;
                        this.selectionEnd = start + newText.length;
                    } else {
                        // Single line indentation
                        this.value = value.substring(0, start) + '    ' + value.substring(end);
                        this.selectionStart = this.selectionEnd = start + 4;
                    }
                    
                    updateLineNumbers();
                    return;
                }
                
                if (e.key === 'Enter') {
                    const beforeCursor = textarea.value.substring(0, textarea.selectionStart);
                    const currentLineStart = beforeCursor.lastIndexOf('\n') + 1;
                    const currentLine = beforeCursor.substring(currentLineStart);
                    const match = currentLine.match(/^(\s*)/);
                    const indentation = match ? match[1] : '';
                    
                    setTimeout(() => {
                        const cursorPos = textarea.selectionStart;
                        const value = textarea.value;
                        textarea.value = value.substring(0, cursorPos) + 
                                       indentation + 
                                       value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = cursorPos + indentation.length;
                        updateLineNumbers();
                    }, 0);
                }
            });
            
            // Initial setup
            updateLineNumbers();
        }
        
        // Update line numbers for specific tab
        function updateLineNumbersForTab(tabName) {
            try {
                const textarea = document.getElementById(tabName + '-code');
                const lineNumbers = document.getElementById(tabName + '-line-numbers');
                
                if (!textarea || !lineNumbers) return;
                
                const lines = textarea.value.split('\n');
                const LINE_HEIGHT = 21;
                const PADDING_TOP = 15;
                const PADDING_BOTTOM = 15;
                
                // Clear existing line numbers
                lineNumbers.innerHTML = '';
                
                // Add all line numbers
                for (let i = 1; i <= lines.length; i++) {
                    const lineNumber = document.createElement('div');
                    lineNumber.textContent = i;
                    lineNumber.style.height = LINE_HEIGHT + 'px';
                    lineNumber.style.lineHeight = LINE_HEIGHT + 'px';
                    lineNumber.style.boxSizing = 'border-box';
                    lineNumbers.appendChild(lineNumber);
                }
                
                const totalHeight = (lines.length * LINE_HEIGHT) + PADDING_TOP + PADDING_BOTTOM;
                lineNumbers.style.minHeight = totalHeight + 'px';
                textarea.style.minHeight = totalHeight + 'px';
                
                // Reset transform
                lineNumbers.style.transform = 'translateY(0)';
            } catch (error) {
                console.error('Error updating line numbers:', error);
            }
        }
        
        // Update all line numbers
        function updateAllLineNumbers() {
            updateLineNumbersForTab('html');
            updateLineNumbersForTab('css');
            updateLineNumbersForTab('js');
        }
        
        // Helper function to clear markers for specific textarea
        function clearMarkersForTextarea(textareaId) {
            const textarea = document.getElementById(textareaId);
            const wrapper = textarea?.parentElement;
            
            if (!wrapper) return;
            
            // Clear error markers
            errorMarkers = errorMarkers.filter(function(item) {
                if (item.textareaId === textareaId) {
                    if (item.marker && item.marker.parentNode === wrapper) {
                        wrapper.removeChild(item.marker);
                    }
                    return false;
                }
                return true;
            });
            
            // Clear warning markers
            warningMarkers = warningMarkers.filter(function(item) {
                if (item.textareaId === textareaId) {
                    if (item.marker && item.marker.parentNode === wrapper) {
                        wrapper.removeChild(item.marker);
                    }
                    return false;
                }
                return true;
            });
            
            // Remove highlight classes
            if (textarea) {
                textarea.classList.remove('error-line', 'warning-line');
            }
        }
        
        // Clear all error and warning markers
        function clearAllMarkers() {
            // Clear all error markers
            errorMarkers.forEach(function(item) {
                if (item.marker && item.marker.remove) {
                    item.marker.remove();
                }
            });
            errorMarkers = [];
            
            // Clear all warning markers
            warningMarkers.forEach(function(item) {
                if (item.marker && item.marker.remove) {
                    item.marker.remove();
                }
            });
            warningMarkers = [];
            
            // Remove highlight classes from all textareas
            document.querySelectorAll('.code-box').forEach(function(box) {
                box.classList.remove('error-line');
                box.classList.remove('warning-line');
            });
        }
        
        // Highlight error or warning line
        function highlightIssue(textareaId, line, message, type) {
            type = type || errorTypes.ERROR;
            const textarea = document.getElementById(textareaId);
            const wrapper = textarea.parentElement;
            
            if (!textarea || !wrapper) return;
            
            const lines = textarea.value.split('\n');
            
            if (line < 1 || line > lines.length) return;
            
            // Clear existing markers for this textarea first
            clearMarkersForTextarea(textareaId);
            
            // Calculate exact position
            const LINE_HEIGHT = 21;
            const paddingTop = 15;
            const lineTop = (line - 1) * LINE_HEIGHT + paddingTop;
            
            // Create marker
            const marker = document.createElement('div');
            marker.className = type === errorTypes.ERROR ? 'error-marker' : 'warning-marker';
            marker.title = message;
            marker.style.top = lineTop + 'px';
            marker.style.height = LINE_HEIGHT + 'px';
            marker.style.left = '45px';
            marker.style.right = '0';
            marker.style.position = 'absolute';
            marker.style.pointerEvents = 'none';
            marker.style.zIndex = '3';
            
            wrapper.appendChild(marker);
            
            if (type === errorTypes.ERROR) {
                errorMarkers.push({ marker: marker, textareaId: textareaId });
            } else {
                warningMarkers.push({ marker: marker, textareaId: textareaId });
            }
            
            // Scroll to the issue line with padding
            const wrapperHeight = wrapper.clientHeight;
            const wrapperScrollTop = wrapper.scrollTop;
            const linePositionInViewport = lineTop - wrapperScrollTop;
            
            // If the line is not visible in the viewport, scroll to it
            if (linePositionInViewport < 0 || linePositionInViewport > wrapperHeight) {
                const targetScroll = Math.max(0, lineTop - wrapperHeight / 2);
                
                wrapper.scrollTo({
                    top: targetScroll,
                    behavior: 'smooth'
                });
            }
            
            // Add highlight class to the line
            setTimeout(function() {
                textarea.classList.add(type === errorTypes.ERROR ? 'error-line' : 'warning-line');
            }, 100);
        }
        
        // Enhanced HTML validation with multiple error detection
        function validateHTML(html) {
            const errors = [];
            if (!html.trim()) return errors;
            
            try {
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const parserErrors = Array.from(doc.querySelectorAll('parsererror'));
                
                if (parserErrors.length > 0) {
                    // Parse multiple errors from parsererror
                    const errorMsg = parserErrors[0].textContent;
                    let line = 1;
                    
                    // Try different patterns to extract line number
                    const lineMatch = errorMsg.match(/line (\d+)/i) || 
                                     errorMsg.match(/at line (\d+)/i) ||
                                     errorMsg.match(/\((\d+),/);
                    
                    if (lineMatch) line = parseInt(lineMatch[1]);
                    
                    // Clean up error message
                    let cleanMsg = errorMsg.replace(/^XML Parsing Error: /, '')
                                          .replace(/Location: .*/, '')
                                          .trim();
                    
                    errors.push({
                        type: errorTypes.ERROR,
                        message: cleanMsg,
                        line: line,
                        tab: 'html'
                    });
                }
                
                // Additional checks for common HTML issues
                const lines = html.split('\n');
                let openTags = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const lineText = lines[i];
                    const lineNum = i + 1;
                    
                    // Check for unclosed tags
                    const tagMatches = lineText.match(/<(\/?)([a-z][a-z0-9]*)(?![^>]*\/>)[^>]*>/gi);
                    if (tagMatches) {
                        for (let j = 0; j < tagMatches.length; j++) {
                            const match = tagMatches[j];
                            const isClosing = match.indexOf('</') === 0;
                            const tagName = match.replace(/<\/?([a-z][a-z0-9]*).*/, '$1').toLowerCase();
                            
                            if (!isClosing && !['br', 'hr', 'img', 'input', 'meta', 'link'].includes(tagName)) {
                                openTags.push({tag: tagName, line: lineNum});
                            } else if (isClosing) {
                                const lastOpenTag = openTags.pop();
                                if (!lastOpenTag || lastOpenTag.tag !== tagName) {
                                    errors.push({
                                        type: errorTypes.ERROR,
                                        message: 'Mismatched tag: </' + tagName + '>',
                                        line: lineNum,
                                        tab: 'html'
                                    });
                                }
                            }
                        }
                    }
                    
                    // Check for common typos
                    if (lineText.includes('calss=')) {
                        errors.push({
                            type: errorTypes.WARNING,
                            message: "Possible typo: 'calss' should be 'class'",
                            line: lineNum,
                            tab: 'html'
                        });
                    }
                }
                
                // Check for unclosed tags
                if (openTags.length > 0) {
                    openTags.forEach(function(tagInfo) {
                        errors.push({
                            type: errorTypes.ERROR,
                            message: 'Unclosed <' + tagInfo.tag + '> tag',
                            line: tagInfo.line,
                            tab: 'html'
                        });
                    });
                }
                
                return errors;
            } catch (err) {
                errors.push({
                    type: errorTypes.ERROR,
                    message: err.message,
                    line: 1,
                    tab: 'html'
                });
                return errors;
            }
        }

        // Enhanced CSS validation with improved error detection
        function validateCSS(css) {
            const errors = [];
            if (!css.trim()) return errors;
            
            try {
                // Create a style element to test CSS validity
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
                
                // Check if the CSS is valid by checking if it's parseable
                if (style.sheet && style.sheet.cssRules) {
                    // Basic validation passed
                } else {
                    errors.push({
                        type: errorTypes.ERROR,
                        message: "Invalid CSS syntax",
                        line: 1,
                        tab: 'css'
                    });
                }
                
                document.head.removeChild(style);
                
                // Additional simple checks
                const lines = css.split('\n');
                let braceCount = 0;
                let inComment = false;
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    const lineNum = i + 1;
                    
                    // Skip empty lines
                    if (!line) continue;
                    
                    // Handle comments
                    if (inComment) {
                        if (line.includes('*/')) {
                            inComment = false;
                            line = line.substring(line.indexOf('*/') + 2).trim();
                        } else {
                            continue;
                        }
                    }
                    
                    if (line.includes('/*')) {
                        inComment = true;
                        if (line.includes('*/')) {
                            inComment = false;
                            line = line.substring(0, line.indexOf('/*')) + line.substring(line.indexOf('*/') + 2);
                        } else {
                            line = line.substring(0, line.indexOf('/*'));
                        }
                    }
                    
                    // Skip single line comments
                    if (line.startsWith('//')) continue;
                    
                    // Count braces for basic balance check
                    braceCount += (line.match(/{/g) || []).length;
                    braceCount -= (line.match(/}/g) || []).length;
                    
                    // Check for obvious syntax errors
                    if (line.includes(';;')) {
                        errors.push({
                            type: errorTypes.WARNING,
                            message: "Double semicolon detected",
                            line: lineNum,
                            tab: 'css'
                        });
                    }
                    
                    // Check for property without semicolon (simple heuristic)
                    if (line.includes(':') && !line.trim().endsWith(';') && !line.trim().endsWith('{') && 
                        !line.trim().endsWith('}') && i < lines.length - 1) {
                        const nextLine = lines[i + 1].trim();
                        if (nextLine && !nextLine.startsWith('/*') && !nextLine.startsWith('//') && 
                            !nextLine.endsWith('}') && !nextLine.includes('{')) {
                            errors.push({
                                type: errorTypes.WARNING,
                                message: "Missing semicolon",
                                line: lineNum,
                                tab: 'css'
                            });
                        }
                    }
                }
                
                if (braceCount !== 0) {
                    errors.push({
                        type: errorTypes.ERROR,
                        message: `Unbalanced braces - ${braceCount > 0 ? braceCount + ' missing }' : Math.abs(braceCount) + ' missing {'}`,
                        line: lines.length,
                        tab: 'css'
                    });
                }
                
                return errors;
            } catch (err) {
                return [{
                    type: errorTypes.ERROR,
                    message: err.message,
                    line: 1,
                    tab: 'css'
                }];
            }
        }

        // Enhanced JS validation with multiple error detection
        function validateJS(js) {
            const errors = [];
            if (!js.trim()) return errors;
            
            try {
                // Syntax validation
                new Function(js);
                
                // Additional static analysis
                const lines = js.split('\n');
                
                // Check for common issues
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i];
                    const lineNum = i + 1;
                    let trimmed = line.trim();
                    
                    // Skip empty lines and comments
                    if (!trimmed || trimmed.startsWith('//')) continue;
                    
                    // Check for assignment in condition (common typo)
                    if (line.includes('if (') && line.includes('=') && !line.includes('==') && !line.includes('===') && 
                        line.indexOf('=') < line.indexOf(')') && line.indexOf('=') > line.indexOf('(')) {
                        // Make sure it's not in a string or comment
                        if (!isInStringOrComment(line, line.indexOf('='))) {
                            errors.push({
                                type: errorTypes.WARNING,
                                message: "Possible assignment in condition, use == or ===",
                                line: lineNum,
                                tab: 'js'
                            });
                        }
                    }
                    
                    // Check for missing semicolons (simple heuristic)
                    const lastChar = trimmed[trimmed.length - 1];
                    if (lastChar && ![';', '{', '}', ')', '(', ',', '.', '=', '+', '-', '*', '/', ':', '?', '!', '[', ']'].includes(lastChar) &&
                        !trimmed.startsWith('//') && !trimmed.startsWith('/*') && !trimmed.endsWith('*/') &&
                        !trimmed.startsWith('function') && !trimmed.startsWith('if') && !trimmed.startsWith('for') && 
                        !trimmed.startsWith('while') && !trimmed.startsWith('const') && !trimmed.startsWith('let') && 
                        !trimmed.startsWith('var') && !trimmed.startsWith('return') && !trimmed.startsWith('console') &&
                        !trimmed.startsWith('export') && !trimmed.startsWith('import') && !trimmed.startsWith('class')) {
                        errors.push({
                            type: errorTypes.WARNING,
                            message: "Missing semicolon",
                            line: lineNum,
                            tab: 'js'
                        });
                    }
                }
                
                return errors;
                
                // Helper function to check if position is in string or comment
                function isInStringOrComment(text, position) {
                    let inSingleLineComment = false;
                    let inMultiLineComment = false;
                    let inString = false;
                    let stringChar = '';
                    
                    for (let i = 0; i < Math.min(position, text.length); i++) {
                        const char = text[i];
                        const nextChar = text[i + 1];
                        
                        if (!inSingleLineComment && !inMultiLineComment && !inString) {
                            if (char === '/' && nextChar === '/') {
                                inSingleLineComment = true;
                                i++; // Skip next char
                            } else if (char === '/' && nextChar === '*') {
                                inMultiLineComment = true;
                                i++; // Skip next char
                            } else if (char === '"' || char === "'" || char === '`') {
                                inString = true;
                                stringChar = char;
                            }
                        } else if (inSingleLineComment) {
                            // Single line comment continues to end of line
                            // We're checking before position, so no need to break
                        } else if (inMultiLineComment && char === '*' && nextChar === '/') {
                            inMultiLineComment = false;
                            i++; // Skip next char
                        } else if (inString && char === stringChar) {
                            // Check for escape character
                            if (text[i - 1] !== '\\') {
                                inString = false;
                            }
                        }
                    }
                    
                    return inSingleLineComment || inMultiLineComment || inString;
                }
            } catch (err) {
                // Extract line number from JS error more reliably
                let line = 1;
                const stackLines = err.stack.split('\n');
                
                for (const stackLine of stackLines) {
                    const match = stackLine.match(/:(\d+):(\d+)\)?$/);
                    if (match) {
                        line = parseInt(match[1]);
                        break;
                    }
                }
                
                errors.push({
                    type: errorTypes.ERROR,
                    message: err.message.replace(/^.*?:\s*/, ''),
                    line: line,
                    tab: 'js'
                });
                return errors;
            }
        }

        // Stop running code
        function stopCode() {
            console.log("Stop button clicked");
            if (currentIframe) {
                currentIframe.remove();
                currentIframe = null;
                document.getElementById("error").textContent = "Execution stopped.";
                updateStatus("Execution stopped");
            }
        }

        // Reset to default code (empty)
        function resetCode() {
            console.log("Reset button clicked");
            document.getElementById("html-code").value = "";
            document.getElementById("css-code").value = "";
            document.getElementById("js-code").value = "";
            clearCode();
            updateAllLineNumbers();
        }

        // Clear output and errors
        function clearCode() {
            console.log("Clear button clicked");
            stopCode();
            document.getElementById("output").innerHTML = "<p>Output will appear here after running your code.</p>";
            document.getElementById("error").textContent = "";
            clearAllMarkers();
            allErrors = [];
            currentErrorIndex = -1;
            tabErrors = { html: [], css: [], js: [] };
            currentTabErrorIndex = { html: -1, css: -1, js: -1 };
            updateErrorNavigation();
            updateErrorSummary();
            updateErrorCount();
            updateStatus("Cleared");
            resetOverride();
        }
        
        // Update status bar
        function updateStatus(message) {
            const status = document.getElementById("status");
            if (status) {
                status.textContent = message;
            }
        }
        
        // Update error count display
        function updateErrorCount() {
            const errorCount = allErrors.filter(function(e) { 
                return e.type === errorTypes.ERROR; 
            }).length;
            const warningCount = allErrors.filter(function(e) { 
                return e.type === errorTypes.WARNING; 
            }).length;
            const errorCountElement = document.getElementById("error-count");
            if (errorCountElement) {
                errorCountElement.textContent = 'Errors: ' + errorCount + ' | Warnings: ' + warningCount;
            }
        }
        
        // Update error summary panel
        function updateErrorSummary() {
            const errorList = document.getElementById("error-list");
            if (!errorList) return;
            
            errorList.innerHTML = "";
            
            if (allErrors.length === 0) {
                const item = document.createElement("li");
                item.className = "error-item";
                item.textContent = "No errors found";
                errorList.appendChild(item);
                return;
            }
            
            allErrors.forEach(function(error, index) {
                const item = document.createElement("li");
                item.className = 'error-item ' + (index === currentErrorIndex ? 'active' : '');
                item.innerHTML = '\
                    <div>\
                        <span class="error-type ' + error.type + '">' + error.type.toUpperCase() + '</span>\
                        ' + error.message + '\
                    </div>\
                    <div class="error-location">Line ' + error.line + '</div>\
                ';
                item.addEventListener("click", function() {
                    navigateToError(index);
                });
                errorList.appendChild(item);
            });
        }
        
        // Update error navigation buttons
        function updateErrorNavigation() {
            const prevBtn = document.getElementById("prev-error");
            const nextBtn = document.getElementById("next-error");
            const currentErrorDisplay = document.getElementById("current-error");
            
            if (!prevBtn || !nextBtn || !currentErrorDisplay) return;
            
            // Get errors for current tab
            const currentTabErrors = tabErrors[currentTab] || [];
            
            if (currentTabErrors.length === 0) {
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                currentErrorDisplay.textContent = "No errors";
                return;
            }
            
            let currentIndex = currentTabErrorIndex[currentTab];
            
            // Ensure current index is valid
            if (currentIndex < 0 || currentIndex >= currentTabErrors.length) {
                currentIndex = currentTabErrors.length > 0 ? 0 : -1;
                currentTabErrorIndex[currentTab] = currentIndex;
            }
            
            prevBtn.disabled = currentIndex <= 0;
            nextBtn.disabled = currentIndex >= currentTabErrors.length - 1;
            
            if (currentTabErrors.length > 0 && currentIndex >= 0) {
                currentErrorDisplay.textContent = 'Error ' + (currentIndex + 1) + ' of ' + currentTabErrors.length;
            } else {
                currentErrorDisplay.textContent = "No errors";
            }
        }
        
        // Navigate to specific error
        function navigateToError(index) {
            if (index < 0 || index >= allErrors.length) return;
            
            currentErrorIndex = index;
            const error = allErrors[index];
            
            // Update tab-specific error index
            const tabErrorList = tabErrors[error.tab];
            let tabIndex = -1;
            if (tabErrorList) {
                for (let i = 0; i < tabErrorList.length; i++) {
                    const e = tabErrorList[i];
                    if (e.line === error.line && e.message === error.message && e.type === error.type) {
                        tabIndex = i;
                        break;
                    }
                }
            }
            
            if (tabIndex !== -1) {
                currentTabErrorIndex[error.tab] = tabIndex;
            }
            
            // Switch to the correct tab
            if (error.tab !== currentTab) {
                showTab(error.tab);
            }
            
            // Highlight the error
            highlightIssue(error.tab + '-code', error.line, error.message, error.type);
            
            // Update navigation
            updateErrorNavigation();
            updateErrorSummary();
            
            updateStatus('Navigated to ' + error.type + ' on line ' + error.line);
        }
        
        // Navigate to next/previous error
        function navigateError(direction) {
            const currentTabErrors = tabErrors[currentTab] || [];
            if (currentTabErrors.length === 0) return;
            
            let currentIndex = currentTabErrorIndex[currentTab];
            
            // Initialize if no current error selected
            if (currentIndex === -1 && currentTabErrors.length > 0) {
                currentIndex = direction > 0 ? 0 : currentTabErrors.length - 1;
            } else {
                currentIndex += direction;
                
                // Wrap around if needed
                if (currentIndex < 0) currentIndex = currentTabErrors.length - 1;
                if (currentIndex >= currentTabErrors.length) currentIndex = 0;
            }
            
            currentTabErrorIndex[currentTab] = currentIndex;
            
            // Find the global index of this error
            const error = currentTabErrors[currentIndex];
            let globalIndex = -1;
            for (let i = 0; i < allErrors.length; i++) {
                const e = allErrors[i];
                if (e.tab === error.tab && e.line === error.line && 
                    e.message === error.message && e.type === error.type) {
                    globalIndex = i;
                    break;
                }
            }
            
            if (globalIndex !== -1) {
                navigateToError(globalIndex);
            }
        }

        // Run code with full validation
        function runCode() {
            console.log("Run button clicked");
            overrideEnabled = false;
            executeCode();
        }

        // Force run code despite errors
        function forceRunCode() {
            console.log("Force Run button clicked");
            overrideEnabled = true;
            executeCode();
        }

        // Main code execution function
        function executeCode() {
            try {
                console.log("Executing code...");
                const html = document.getElementById("html-code").value;
                const css = document.getElementById("css-code").value;
                const js = document.getElementById("js-code").value;
                
                const output = document.getElementById("output");
                const errorDisplay = document.getElementById("error");
                
                if (!output || !errorDisplay) {
                    console.error("Output or error display element not found");
                    return;
                }
                
                // Clear previous
                stopCode();
                clearAllMarkers();
                errorDisplay.textContent = "";
                allErrors = [];
                currentErrorIndex = -1;
                tabErrors = { html: [], css: [], js: [] };
                currentTabErrorIndex = { html: -1, css: -1, js: -1 };
                
                updateStatus("Validating code...");
                
                // Validate all code types
                const htmlErrors = validateHTML(html);
                const cssErrors = validateCSS(css);
                const jsErrors = validateJS(js);
                
                // Combine all errors and organize by tab
                allErrors = htmlErrors.concat(cssErrors).concat(jsErrors);
                tabErrors.html = htmlErrors;
                tabErrors.css = cssErrors;
                tabErrors.js = jsErrors;
                
                // Update UI with errors
                updateErrorCount();
                updateErrorSummary();
                updateErrorNavigation();
                
                // Check if we should proceed with execution
                const hasErrors = allErrors.length > 0;
                const hasCriticalErrors = allErrors.some(error => error.type === errorTypes.ERROR);
                
                // If there are errors and override is not enabled, show the first one
                if (hasErrors && !overrideEnabled && !alwaysOverride) {
                    // Find first error for current tab, or first error overall
                    let firstErrorIndex = 0;
                    const currentTabError = tabErrors[currentTab];
                    if (currentTabError && currentTabError.length > 0) {
                        for (let i = 0; i < allErrors.length; i++) {
                            const e = allErrors[i];
                            if (e.tab === currentTabError[0].tab && 
                                e.line === currentTabError[0].line && 
                                e.message === currentTabError[0].message) {
                                firstErrorIndex = i;
                                break;
                            }
                        }
                    }
                    
                    if (firstErrorIndex !== -1) {
                        navigateToError(firstErrorIndex);
                    }
                    
                    const errorText = hasCriticalErrors ? 
                        'Found ' + allErrors.length + ' issues. Fix errors or use "Force Run" to override.' :
                        'Found ' + allErrors.length + ' warnings. Review or use "Force Run" to override.';
                        
                    errorDisplay.textContent = errorText;
                    updateStatus('Found ' + allErrors.length + ' issues');
                    return;
                }
                
                // If we're overriding, show a warning but proceed
                if ((overrideEnabled || alwaysOverride) && hasErrors) {
                    updateStatus("Overriding " + allErrors.length + " issues and running code...");
                    errorDisplay.textContent = "Running code with " + allErrors.length + " known issues (override active)";
                    
                    // Still show the first error for reference, but don't block execution
                    if (allErrors.length > 0) {
                        navigateToError(0);
                    }
                } else {
                    updateStatus("Running code...");
                }
                
                // Create new iframe for output
                currentIframe = document.createElement("iframe");
                currentIframe.className = "output-frame";
                currentIframe.sandbox = "allow-scripts allow-same-origin";
                output.innerHTML = "";
                output.appendChild(currentIframe);
                
                const iframeDoc = currentIframe.contentDocument || currentIframe.contentWindow.document;
                
                // Generate a unique ID for this iframe for message identification
                const iframeId = 'iframe_' + Date.now();
                currentIframe.dataset.iframeId = iframeId;
                
                iframeDoc.open();
                iframeDoc.write('\
                    <!DOCTYPE html>\
                    <html>\
                        <head>\
                            <meta charset="UTF-8">\
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">\
                            <style>' + css + '</style>\
                        </head>\
                        <body>' + html + '\
                            <script>\
                                // Enhanced error handling for runtime errors with postMessage\
                                window.addEventListener(\'error\', function(e) {\
                                    const errorInfo = {\
                                        type: \'runtimeError\',\
                                        iframeId: \'' + iframeId + '\',\
                                        message: e.message,\
                                        filename: e.filename,\
                                        lineno: e.lineno,\
                                        colno: e.colno,\
                                        stack: e.error?.stack\
                                    };\
                                    window.parent.postMessage(errorInfo, \'*\');\
                                    return false;\
                                });\
                                \
                                // Catch unhandled promise rejections\
                                window.addEventListener(\'unhandledrejection\', function(e) {\
                                    const errorInfo = {\
                                        type: \'unhandledRejection\',\
                                        iframeId: \'' + iframeId + '\',\
                                        message: "Unhandled Promise Rejection: " + e.reason,\
                                        lineno: 1\
                                    };\
                                    window.parent.postMessage(errorInfo, \'*\');\
                                });\
                                \
                                try {\
                                    ' + js + '\
                                } catch (err) {\
                                    const errorInfo = {\
                                        type: \'executionError\',\
                                        iframeId: \'' + iframeId + '\',\
                                        message: err.message,\
                                        lineno: err.lineNumber || 1,\
                                        stack: err.stack\
                                    };\
                                    window.parent.postMessage(errorInfo, \'*\');\
                                }\
                            <\/script>\
                        </body>\
                    </html>\
                ');
                iframeDoc.close();
                
                const statusMessage = (overrideEnabled || alwaysOverride) && hasErrors ? 
                    "Code executed with " + allErrors.length + " overridden issues" :
                    "Code executed successfully";
                    
                updateStatus(statusMessage);
            } catch (err) {
                console.error("Error in executeCode:", err);
                displayError("Execution Error: " + err.message);
                updateStatus("Error executing code");
            }
        }
        
        // Update override toggle UI
        function updateOverrideToggle() {
            const toggle = document.getElementById('override-toggle');
            const checkbox = document.getElementById('override-checkbox');
            const overrideBtn = document.getElementById('override-btn');
            
            if (!toggle || !checkbox || !overrideBtn) return;
            
            if (alwaysOverride) {
                toggle.classList.add('override-active');
                overrideBtn.classList.add('active');
                overrideBtn.disabled = true;
                overrideBtn.title = "Override is always enabled";
            } else {
                toggle.classList.remove('override-active');
                overrideBtn.classList.remove('active');
                overrideBtn.disabled = false;
                overrideBtn.title = "Run code despite validation issues";
            }
        }
        
        // Reset override state
        function resetOverride() {
            overrideEnabled = false;
            alwaysOverride = false;
            const checkbox = document.getElementById('override-checkbox');
            if (checkbox) {
                checkbox.checked = false;
            }
            updateOverrideToggle();
        }
        
        // Enhanced message listener with security validation
        window.addEventListener('message', function(event) {
            // Security check - only accept messages from same origin
            // Note: For local files, origin may be null, so we'll allow that
            if (event.origin !== window.location.origin && event.origin !== "null" && event.origin !== "") {
                return;
            }
            
            // Check if this message is from our iframe
            if (currentIframe && event.data && event.data.iframeId === currentIframe.dataset.iframeId) {
                const errorInfo = event.data;
                
                const error = {
                    type: errorTypes.ERROR,
                    message: errorInfo.message,
                    line: errorInfo.lineno || 1,
                    tab: 'js' // Runtime errors are always from JS
                };
                
                allErrors.push(error);
                if (!tabErrors.js) tabErrors.js = [];
                tabErrors.js.push(error);
                
                updateErrorCount();
                updateErrorSummary();
                
                // If this is the first error, navigate to it
                if (allErrors.length === 1) {
                    navigateToError(0);
                }
                
                const errorDisplay = document.getElementById("error");
                if (errorDisplay) {
                    errorDisplay.textContent = 'Runtime Error: ' + errorInfo.message;
                }
                updateStatus("Runtime error detected");
            }
        });
        
        function displayError(err) {
            const errorDisplay = document.getElementById("error");
            if (errorDisplay) {
                errorDisplay.textContent = err;
            }
            updateStatus("Error detected");
        }

        // Make panels resizable
        function setupResizers() {
            const container = document.querySelector('.editor-container');
            const resizer = document.getElementById('resizer');
            
            if (!container || !resizer) return;
            
            const leftPanel = container.children[0];
            const rightPanel = container.children[2];
            
            let isResizing = false;
            
            resizer.addEventListener('mousedown', function(e) {
                isResizing = true;
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                const percent = Math.min(Math.max((e.clientX - containerRect.left) / containerRect.width * 100, 20), 80);
                
                leftPanel.style.flex = '0 0 ' + percent + '%';
                rightPanel.style.flex = '0 0 ' + (100 - percent) + '%';
            });
            
            document.addEventListener('mouseup', function() {
                isResizing = false;
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
            });
            
            // Handle touch events for mobile
            resizer.addEventListener('touchstart', function(e) {
                isResizing = true;
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isResizing) return;
                
                const touch = e.touches[0];
                const containerRect = container.getBoundingClientRect();
                const percent = Math.min(Math.max((touch.clientX - containerRect.left) / containerRect.width * 100, 20), 80);
                
                leftPanel.style.flex = '0 0 ' + percent + '%';
                rightPanel.style.flex = '0 0 ' + (100 - percent) + '%';
                
                e.preventDefault();
            });
            
            document.addEventListener('touchend', function() {
                isResizing = false;
            });
        }
    </script>
</body>
</html>
